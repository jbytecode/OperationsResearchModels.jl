var documenterSearchIndex = {"docs":
[{"location":"scheduling/#Scheduling-Problems","page":"Scheduling","title":"Scheduling Problems","text":"","category":"section"},{"location":"scheduling/#Flow-Shop-Problem","page":"Scheduling","title":"Flow-Shop Problem","text":"","category":"section"},{"location":"scheduling/#Johnson's-Rule-for-Flow-shop-Scheduling","page":"Scheduling","title":"Johnson's Rule for Flow-shop Scheduling","text":"","category":"section"},{"location":"scheduling/#Flow-Shop-Result","page":"Scheduling","title":"Flow-Shop Result","text":"","category":"section"},{"location":"scheduling/#Genetic-Algorithm-for-the-problems-that-cannot-be-solved-with-using-Johnson's-Rule","page":"Scheduling","title":"Genetic Algorithm for the problems that cannot be solved with using Johnson's Rule","text":"","category":"section"},{"location":"scheduling/#Makespan","page":"Scheduling","title":"Makespan","text":"","category":"section"},{"location":"scheduling/#OperationsResearchModels.Johnsons.JohnsonProblem","page":"Scheduling","title":"OperationsResearchModels.Johnsons.JohnsonProblem","text":"JohnsonProblem\n\nDescription\n\nRepresents a Johnson problem instance, containing the job processing times.\n\nFields\n\ntimes::Matrix{<:Real}: A matrix of job processing times.\n\n\n\n\n\n","category":"type"},{"location":"scheduling/#OperationsResearchModels.solve-Tuple{JohnsonProblem}","page":"Scheduling","title":"OperationsResearchModels.solve","text":"johnsons(problem::JohnsonProblem)::JohnsonResult\n\nGiven a problem containing a matrix of times, returns a JohnsonResult with the permutation of the jobs.  If number of machines is 2, it uses the Johnson's algorithm for 2 machines. If number of machines is greater than 2, it uses the Johnson's algorithm by transforming the  problem into a 2-machine problem. In order to reduce the original problem to a 2-machine problem, the algorithm checks if the minimum time of the first machine is greater or equal than the maximum time of the other machines and/or if the minimum time of the  last machine is greater or equal than the maximum time of the other machines.\n\nFor example if we have 4 machines, namely, A, B, C, and D  at least one of the following conditions must be satisfied:\n\nmin(A) >= max(B, C)\nmin(D) >= max(B, C)\n\nThe function throws a JohnsonException if the problem cannot be reduced to a 2-machine problem.\n\nArguments\n\nproblem::JohnsonProblem: a problem containing a matrix of times\n\nReturns\n\nJohnsonResult: a custom data type that holds the permutation of the jobs\n\nExample\n\ntimes = Float64[\n    3.1 2.8;\n    4.0 7.0;\n    8.0 3.0;\n    5.0 8.0;\n    6.0 4.0;\n    8.0 5.0;\n    7.0 4.0\n]\n\nresult = solve(JohnsonProblem(times))\n\nprintln(result.permutation)\n\n\n\n\n\n","category":"method"},{"location":"scheduling/#OperationsResearchModels.Johnsons.JohnsonResult","page":"Scheduling","title":"OperationsResearchModels.Johnsons.JohnsonResult","text":"JohnsonResult\n\nDescription\n\nRepresents the result of the Johnson's algorithm, containing the optimal job permutation.\n\nFields\n\npermutation::Vector{Int}: The optimal job permutation found by the algorithm.\n\n\n\n\n\n","category":"type"},{"location":"scheduling/#OperationsResearchModels.Johnsons.johnsons_ga","page":"Scheduling","title":"OperationsResearchModels.Johnsons.johnsons_ga","text":"johnsons_ga(problem::JohnsonProblem; popsize = 100, ngen = 1000, pcross = 0.8, pmutate = 0.01, nelites = 1)::JohnsonResult\n\nGiven a problem containing a matrix of times, returns a JohnsonResult with the permutation of the jobs. The function uses a genetic algorithm to find the best permutation of the jobs. The genetic algorithm is implemented in the RandomKeyGA module.\n\nArguments\n\nproblem::JohnsonProblem: a problem containing a matrix of times\npopsize::Int: the population size. Default is 100\nngen::Int: the number of generations. Default is 1000\npcross::Float64: the crossover probability. Default is 0.8\npmutate::Float64: the mutation probability. Default is 0.01\nnelites::Int: the number of elites. Default is 1\n\nReturns\n\nJohnsonResult: a custom data type that holds the permutation of the jobs\n\nExample\n\ntimes = Float64[\n    3.1 2.8;\n    4.0 7.0;\n    8.0 3.0;\n    5.0 8.0;\n    6.0 4.0;\n    8.0 5.0;\n    7.0 4.0\n]\n\nresult = johnsons_ga(JohnsonProblem(times))\n\nprintln(result.permutation)\n\n\n\n\n\n","category":"function"},{"location":"scheduling/#OperationsResearchModels.Johnsons.makespan","page":"Scheduling","title":"OperationsResearchModels.Johnsons.makespan","text":"makespan(problem::JohnsonProblem, permutation::Vector{Int})\n\nGiven a problem containing a matrix of times and a permutation of the jobs, returns the makespan of the jobs.\n\nArguments\n\nproblem::JohnsonProblem: a problem containing a matrix of times\npermutation::Vector{Int}: a permutation of the jobs\n\nReturns\n\nFloat64: the makespan of the jobs\n\nExample\n\n\ntimes = Float64[\n    3 3 5;\n    8 4 8;\n    7 2 10;\n    5 1 7;\n    2 5 6    \n]\n\nresult = makespan(JohnsonProblem(times), [1, 4, 5, 3, 2])\n\n\n\n\n\n","category":"function"},{"location":"knapsack/#The-Classical-Knapsack-Problem-Solver","page":"Knapsack","title":"The Classical Knapsack Problem Solver","text":"","category":"section"},{"location":"knapsack/#KnapsackProblem","page":"Knapsack","title":"KnapsackProblem","text":"","category":"section"},{"location":"knapsack/#The-Solver","page":"Knapsack","title":"The Solver","text":"","category":"section"},{"location":"knapsack/#KnapsackResult","page":"Knapsack","title":"KnapsackResult","text":"","category":"section"},{"location":"knapsack/#OperationsResearchModels.Knapsack.KnapsackProblem","page":"Knapsack","title":"OperationsResearchModels.Knapsack.KnapsackProblem","text":"KnapsackProblem\n\nDescription\n\nDefines the knapsack problem.\n\nFields\n\nvalues::Vector{Float64}: The values of the items.\nweights::Vector{Float64}: The weights of the items.\ncapacity::Float64: The maximum capacity of the knapsack.\n\nOutput\n\nKnapsackResult: The custom data type that holds selected items, model, and objective value.\n\n\n\n\n\n","category":"type"},{"location":"knapsack/#OperationsResearchModels.solve-Tuple{KnapsackProblem}","page":"Knapsack","title":"OperationsResearchModels.solve","text":"solve(problem::KnapsackProblem)::KnapsackResult\n\nDescription\n\nSolves the knapsack problem.\n\nArguments\n\nproblem::KnapsackProblem: The problem in type of KnapsackProblem.\n\nOutput\n\nKnapsackResult: The custom data type that holds selected items, model, and objective value.\n\nExample\n\nvalues = [10, 20, 30, 40, 50];\nweights = [1, 2, 3, 4, 5];\ncapacity = 10;\nsolve(KnapsackProblem(values, weights, capacity));\n\n\n\n\n\n","category":"method"},{"location":"knapsack/#OperationsResearchModels.Knapsack.KnapsackResult","page":"Knapsack","title":"OperationsResearchModels.Knapsack.KnapsackResult","text":"KnapsackResult\n\nDescription\n\nA structure to hold the result of the knapsack problem.\n\nFields\n\nselected: A vector of booleans indicating which items are selected.\nmodel: The JuMP model used to solve the problem.\nobjective: The objective value of the model.\n\n\n\n\n\n","category":"type"},{"location":"simplex/#The-Simplex-Method","page":"The Simplex Method","title":"The Simplex Method","text":"","category":"section"},{"location":"simplex/#createsimplexproblem","page":"The Simplex Method","title":"createsimplexproblem","text":"","category":"section"},{"location":"simplex/#solve!","page":"The Simplex Method","title":"solve!","text":"","category":"section"},{"location":"simplex/#simplexiterations","page":"The Simplex Method","title":"simplexiterations","text":"","category":"section"},{"location":"simplex/#Gauss-Jordan-steps-for-matrix-inversion","page":"The Simplex Method","title":"Gauss Jordan steps for matrix inversion","text":"","category":"section"},{"location":"simplex/#OperationsResearchModels.Simplex.createsimplexproblem","page":"The Simplex Method","title":"OperationsResearchModels.Simplex.createsimplexproblem","text":"createsimplexproblem(obj::Vector, amat::Matrix, rhs::Vector, dir::Vector, opttype::OptimizationType)::SimplexProblem\n\nDescription\n\nThis function creates a SimplexProblem object from the given parameters. \n\nArguments\n\nobj::Vector: The objective function coefficients.\namat::Matrix: The LHS of the constraints.\nrhs::Vector: The RHS of the constraints.\ndir::Vector: The directions of the constraints. Can be a vector of LE (<=), GE (>=), or EQ (==).\nopttype::OptimizationType: The type of the optimization. Can be Maximize or Minimize.\n\nReturns\n\nA SimplexProblem object.\n\nExample\n\nSuppose the linear programming problem is as follows:\n\nMaximize: 1.0x1 + 2.0x2 + 3.0x3\nSubject to:\n1.0x1 + 2.0x2 + 3.0x3 <= 10.0\n3.0x1 + 1.0x2 + 5.0x3 <= 15.0\nx1, x2 >= 0\n\nThe following code creates a SimplexProblem object for the above problem:\n\nusing OperationsResearchModels.Simplex\n\nobj = Float64[1.0, 2.0, 3.0]\namat = Float64[1.0 2.0 3.0; 3.0 1.0 5.0]\nrhs = Float64[10.0, 15.0]\ndir = [LE, LE]\nopttype = Maximize\n\ns = createsimplexproblem(obj, amat, rhs, dir, opttype)\niters = simplexiterations(s)\n\n\n\n\n\n","category":"function"},{"location":"simplex/#OperationsResearchModels.solve!-Tuple{SimplexProblem}","page":"The Simplex Method","title":"OperationsResearchModels.solve!","text":"solve!(s::SimplexProblem)::SimplexProblem\n\nDescription\n\nSolves the given SimplexProblem using the Simplex algorithm. The solve! function  modifies the input SimplexProblem in place.\n\nArguments\n\ns::SimplexProblem: The SimplexProblem to solve.\n\nReturns\n\nSimplexProblem: The solved SimplexProblem.\n\n\n\n\n\n","category":"method"},{"location":"simplex/#OperationsResearchModels.Simplex.simplexiterations","page":"The Simplex Method","title":"OperationsResearchModels.Simplex.simplexiterations","text":"simplexiterations(s::SimplexProblem)::Vector{SimplexProblem}\n\nDescription\n\nThis function performs the Simplex iterations on the given SimplexProblem and returns the  history of SimplexProblem states.\n\nArguments\n\ns::SimplexProblem: The SimplexProblem to iterate.\n\nReturns\n\nVector{SimplexProblem}: The history of SimplexProblem states (by iterations).\n\n\n\n\n\n","category":"function"},{"location":"simplex/#OperationsResearchModels.Simplex.gaussjordan","page":"The Simplex Method","title":"OperationsResearchModels.Simplex.gaussjordan","text":"gaussjordan(A::Matrix; verbose::Bool = true)::Matrix\n\nDescription\n\nAttaches an Identity matrix to the right of the given matrix A and applies the Gauss-Jordan elimination method to find the inverse of the given matrix.\n\nArguments\n\nA::Matrix: The matrix to find the inverse.\nverbose::Bool: If true, the intermediate steps are displayed. Default is true.\n\nReturns\n\nThe inverse of the given matrix.\n\nExample\n\nA = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 10.0]\ninvA = gaussjordan(A, verbose = false)\n\n# 3×3 Matrix{Float64}:\n#  -0.666667  -1.33333   1.0\n#  -0.666667   3.66667  -2.0\n#   1.0       -2.0       1.0\n\n\n\n\n\n","category":"function"},{"location":"assignment/#Assignment-Problem","page":"Assignment","title":"Assignment Problem","text":"","category":"section"},{"location":"assignment/#AssignmentProblem","page":"Assignment","title":"AssignmentProblem","text":"","category":"section"},{"location":"assignment/#Assignment-Problem-Solver","page":"Assignment","title":"Assignment Problem Solver","text":"","category":"section"},{"location":"assignment/#AssignmentResult","page":"Assignment","title":"AssignmentResult","text":"","category":"section"},{"location":"assignment/#OperationsResearchModels.Assignment.AssignmentProblem","page":"Assignment","title":"OperationsResearchModels.Assignment.AssignmentProblem","text":"AssignmentProblem\n\nFields\n\ncosts::Matrix{T}: The cost matrix of the assignment problem.\n\nDescription\n\nThe AssignmentProblem struct represents an assignment problem with a cost matrix.\n\n\n\n\n\n","category":"type"},{"location":"assignment/#OperationsResearchModels.solve-Tuple{AssignmentProblem}","page":"Assignment","title":"OperationsResearchModels.solve","text":"solve(a)\n\nArguments\n\na::AssignmentProblem: The problem in type of AssignmentProblem\n\nOutput\n\nAssignmentResult: The custom data type that holds problem, solution, and optimum cost. \n\nDescription\n\nSolves an assignment problem given by an object of in type AssignmentProblem.\n\nExample\n\nmat = [\n        4 8 1;\n        3 1 9;\n        1 6 7;\n    ];\n\nproblem = AssignmentProblem(mat);\n\nresult = solve(problem);\n\n\n\n\n\n","category":"method"},{"location":"assignment/#OperationsResearchModels.Assignment.AssignmentResult","page":"Assignment","title":"OperationsResearchModels.Assignment.AssignmentResult","text":"AssignmentResult\n\nFields\n\nproblem::AssignmentProblem: The original assignment problem.\nsolution::Matrix: The solution matrix of the assignment problem.\ncost::Real: The optimal cost of the assignment.\nmodel::JuMP.Model: The JuMP model used to solve the problem.\n\nDescription\n\nThe AssignmentResult struct represents the result of solving an assignment problem. It contains the original problem, the solution matrix, and the optimal cost.\n\n\n\n\n\n","category":"type"},{"location":"network/#Network-Models","page":"Network","title":"Network Models","text":"","category":"section"},{"location":"network/#Connection","page":"Network","title":"Connection","text":"","category":"section"},{"location":"network/#ShortestPathProblem","page":"Network","title":"ShortestPathProblem","text":"","category":"section"},{"location":"network/#Shortest-Path","page":"Network","title":"Shortest Path","text":"","category":"section"},{"location":"network/#ShortestPathResult","page":"Network","title":"ShortestPathResult","text":"","category":"section"},{"location":"network/#Maximum-Flow-Problem","page":"Network","title":"Maximum Flow Problem","text":"","category":"section"},{"location":"network/#Maximum-Flow","page":"Network","title":"Maximum Flow","text":"","category":"section"},{"location":"network/#MaximumFlowResult","page":"Network","title":"MaximumFlowResult","text":"","category":"section"},{"location":"network/#MinimumCostFlowProblem","page":"Network","title":"MinimumCostFlowProblem","text":"","category":"section"},{"location":"network/#Minimum-Cost-Flow","page":"Network","title":"Minimum Cost Flow","text":"","category":"section"},{"location":"network/#MinimumCostFlowResult","page":"Network","title":"MinimumCostFlowResult","text":"","category":"section"},{"location":"network/#MstProblem","page":"Network","title":"MstProblem","text":"","category":"section"},{"location":"network/#Minimum-Spanning-Tree","page":"Network","title":"Minimum Spanning Tree","text":"","category":"section"},{"location":"network/#MstResult","page":"Network","title":"MstResult","text":"","category":"section"},{"location":"network/#OperationsResearchModels.Network.Connection","page":"Network","title":"OperationsResearchModels.Network.Connection","text":" Connection\n\nDescription\n\nA structure to hold a directed connection between two nodes in a network.\n\nFields\n\nfrom::Int64: The starting node of the connection.\nto::Int64: The ending node of the connection.\nvalue::Real: The value associated with the connection (e.g. distance, time, capacity). \n\nExample\n\n# Create a connection from node 1 to node 2 with a distance of 5 kms.\nconn = Connection(1, 2, 5)\n\n\n\n\n\n","category":"type"},{"location":"network/#OperationsResearchModels.ShortestPath.ShortestPathProblem","page":"Network","title":"OperationsResearchModels.ShortestPath.ShortestPathProblem","text":"ShortestPathProblem\n\nDescription\n\nDefines the shortest path problem.\n\nFields\n\nconnections::Vector{Connection}: The connections (edges) in the network.\n\n\n\n\n\n","category":"type"},{"location":"network/#OperationsResearchModels.solve-Tuple{ShortestPathProblem}","page":"Network","title":"OperationsResearchModels.solve","text":"solve(problem)\n\nDescription\n\nSolves a shortest path problem given by an object of in type ShortestPathProblem.\n\nArguments\n\nproblem::ShortestPathProblem: The problem in type of ShortestPathProblem\n\nOutput\n\nShortestPathResult: The custom data type that holds path and cost.\n\nExample\n\nconns = [\n    Connection(1, 2, 3),\n    Connection(1, 3, 2),\n    Connection(1, 4, 4),\n    Connection(2, 5, 3),\n    Connection(3, 5, 1),\n    Connection(3, 6, 1),\n    Connection(4, 6, 2),\n    Connection(5, 7, 6),\n    Connection(6, 7, 5),\n]\n\nresult = solve(ShortestPathProblem(conns))\n\nprintln(result.path)\n# 3-element Vector{Connection}:\n#  Connection(1, 3, 2)\n#  Connection(3, 6, 1)\n#  Connection(6, 7, 5)\n\nprintln(result.cost)\n# 8.0\n\ninfo: Determining start and finish nodes\nIn this function it's assumed that the problem has a unique start and finish node. A heuristic approach is used to find the start and finish nodes. If a node has only outcoming connections, it is considered the start node. If a node has only incoming connections, it is considered the finish node. Of course a network can have multiple start and finish nodes, but this heuristic simplifies the problem. Future implementations could explore more complex scenarios with multiple start and finish nodes. \n\n\n\n\n\n","category":"method"},{"location":"network/#OperationsResearchModels.ShortestPath.ShortestPathResult","page":"Network","title":"OperationsResearchModels.ShortestPath.ShortestPathResult","text":"ShortestPathResult\n\nDescription\n\nA structure to hold the result of the shortest path problem.\n\nFields\n\npath::Vector{Connection}: The connections (edges) in the shortest path.\ncost::Float64: The total cost of the shortest path.\nmodel::JuMP.Model: The JuMP model used to solve the problem.\n\n\n\n\n\n","category":"type"},{"location":"network/#OperationsResearchModels.MaximumFlow.MaximumFlowProblem","page":"Network","title":"OperationsResearchModels.MaximumFlow.MaximumFlowProblem","text":"MaximumFlowProblem\n\nDescription\n\nDefines the maximum flow problem.\n\nFields\n\nconnections::Vector{Connection}: The connections (edges) in the network.\n\n\n\n\n\n","category":"type"},{"location":"network/#OperationsResearchModels.solve-Tuple{MaximumFlowProblem}","page":"Network","title":"OperationsResearchModels.solve","text":"solve(problem)\n\nDescription\n\nSolves a maximum flow problem given by an object of in type MaximumFlowProblem.\n\nArguments\n\nproblem::MaximumFlowProblem: The problem in type of MaximumFlowProblem\n\nOutput\n\nMaximumFlowResult: The custom data type that holds path and flow.\n\nExample\n\nconns = [\n    Connection(1, 2, 3),\n    Connection(1, 3, 2),\n    Connection(1, 4, 4),\n    Connection(2, 5, 3),\n    Connection(3, 5, 1),\n    Connection(3, 6, 1),\n    Connection(4, 6, 2),\n    Connection(5, 7, 6),\n    Connection(6, 7, 5),\n];\n\nproblem = MaximumFlowProblem(conns)\n\nresult = solve(problem);\n\nprintln(result.path)\n\nprintln(result.flow)\n\ninfo: Determining start and finish nodes\nIn this function it's assumed that the problem has a unique start and finish node. A heuristic approach is used to find the start and finish nodes. If a node has only outcoming connections, it is considered the start node. If a node has only incoming connections, it is considered the finish node. Of course a network can have multiple start and finish nodes, but this heuristic simplifies the problem. Future implementations could explore more complex scenarios with multiple start and finish nodes. \n\n\n\n\n\n","category":"method"},{"location":"network/#OperationsResearchModels.MaximumFlow.MaximumFlowResult","page":"Network","title":"OperationsResearchModels.MaximumFlow.MaximumFlowResult","text":"MaximumFlowResult\n\nDescription\n\nA structure to hold the result of the maximum flow problem.\n\nFields\n\npath::Vector{Connection}: The connections (edges) in the flow path.\nflow::Float64: The total flow through the network.\nmodel::JuMP.Model: The JuMP model used to solve the problem.\n\n\n\n\n\n","category":"type"},{"location":"network/#OperationsResearchModels.MinimumCostFlow.MinimumCostFlowProblem","page":"Network","title":"OperationsResearchModels.MinimumCostFlow.MinimumCostFlowProblem","text":"MinimumCostFlowProblem\n\nDescription\n\nDefines the minimum cost flow problem.\n\nFields\n\nconnections::Vector{Connection}: The connections (edges) in the network.\ncosts::Vector{Connection}: The costs associated with each connection.\n\n\n\n\n\n","category":"type"},{"location":"network/#OperationsResearchModels.solve-Tuple{MinimumCostFlowProblem}","page":"Network","title":"OperationsResearchModels.solve","text":"solve(problem)\n\nDescription\n\nThis function solves the Minimum Cost Flow problem by first solving the Maximum Flow problem and  then using the flow value to solve the Minimum Cost Flow problem.\n\nArguments\n\nproblem::MinimumCostFlowProblem: The problem in type of MinimumCostFlowProblem\n\ninfo: Determining start and finish nodes\nIn this function it's assumed that the problem has a unique start and finish node. A heuristic approach is used to find the start and finish nodes. If a node has only outcoming connections, it is considered the start node. If a node has only incoming connections, it is considered the finish node. Of course a network can have multiple start and finish nodes, but this heuristic simplifies the problem. Future implementations could explore more complex scenarios with multiple start and finish nodes. \n\n\n\n\n\n","category":"method"},{"location":"network/#OperationsResearchModels.solve-Tuple{MinimumCostFlowProblem, Float64}","page":"Network","title":"OperationsResearchModels.solve","text":"solve(problem, flow)\n\nDescription\n\nThis function solves the Minimum Cost Flow problem given a flow value.\n\nArguments\n\nproblem::MinimumCostFlowProblem: The problem in type of MinimumCostFlowProblem\nflow::Float64: The flow value to be used in the problem.\n\n\n\n\n\n","category":"method"},{"location":"network/#OperationsResearchModels.MinimumCostFlow.MinimumCostFlowResult","page":"Network","title":"OperationsResearchModels.MinimumCostFlow.MinimumCostFlowResult","text":"MinimumCostFlowResult\n\nDescription\n\nA structure to hold the result of the minimum cost flow problem.\n\nFields\n\npath::Vector{Connection}: The connections (edges) in the flow path.\ncost::Float64: The total cost of the flow.\nmodel::JuMP.Model: The JuMP model used to solve the problem.\n\n\n\n\n\n","category":"type"},{"location":"network/#OperationsResearchModels.MinimumSpanningTree.MstProblem","page":"Network","title":"OperationsResearchModels.MinimumSpanningTree.MstProblem","text":"MstProblem\n\nDescription\n\nDefines the minimum spanning tree problem.\n\nFields\n\nconnections::Vector{Connection}: The connections (edges) in the network. \n\ninfo: Interpreting the Connection object\nThe Connection object defines a directed edge, but for the minimum spanning tree problem,  the edges are considered undirected.\n\n\n\n\n\n","category":"type"},{"location":"network/#OperationsResearchModels.solve-Tuple{MstProblem}","page":"Network","title":"OperationsResearchModels.solve","text":"solve(problem::MstProblem)\n\nDescription\n\nObtains the minimum spanning tree. \n\nArguments\n\nproblem::MstProblem: The problem in type of MstProblem\n\nOutput\n\n::MstResult: A MstResult object that holds the results. \n\nDetails\n\nThis function uses Prim's algorithm to find the minimum spanning tree. It maintains a set of assigned and unassigned nodes, expanding the tree by adding the nearest unassigned node.\n\nExamples\n\nconns = Connection[\n    Connection(1, 2, 10),\n    Connection(2, 3, 10),\n    Connection(3, 4, 10),\n    Connection(1, 4, 10)\n]\n\nresult = solve(MstProblem(conns))\n\nMstResult(Connection[Connection(3, 4, 10), Connection(1, 4, 10), Connection(2, 3, 10)], 30.0)\n\nprintln(result.distance)\n\nprintln(result.connections)\n\n\n\n\n\n","category":"method"},{"location":"network/#OperationsResearchModels.MinimumSpanningTree.MstResult","page":"Network","title":"OperationsResearchModels.MinimumSpanningTree.MstResult","text":"MstResult\n\nDescription\n\nA structure to hold the result of the minimum spanning tree problem.\n\nFields\n\nconnections::Vector{Connection}: The connections (edges) in the minimum spanning tree.\ndistance::Float64: The total distance (weight) of the minimum spanning tree.\n\n\n\n\n\n","category":"type"},{"location":"game/#Zero-Sum-Games","page":"Zero-sum Games","title":"Zero-Sum Games","text":"","category":"section"},{"location":"game/#Game-Problem","page":"Zero-sum Games","title":"Game Problem","text":"","category":"section"},{"location":"game/#Game-solver-of-the-game-matrix-designed-for-the-row-player","page":"Zero-sum Games","title":"Game solver of the game matrix designed for the row player","text":"","category":"section"},{"location":"game/#GameResult","page":"Zero-sum Games","title":"GameResult","text":"","category":"section"},{"location":"game/#OperationsResearchModels.Game.GameProblem","page":"Zero-sum Games","title":"OperationsResearchModels.Game.GameProblem","text":"GameProblem\n\nDescription\n\nDefines the problem of a zero-sum game.\n\nFields\n\ndecisionMatrix::Matrix{<:Real}: The payoff matrix of the game designed for the row player.\n\n\n\n\n\n","category":"type"},{"location":"game/#OperationsResearchModels.solve-Tuple{GameProblem}","page":"Zero-sum Games","title":"OperationsResearchModels.solve","text":"solve(p::GameProblem; verbose::Bool = false)::Vector{GameResult}\n\nSolves a zero-sum game using the simplex method.\n\nArguments\n\np::GameProblem: The problem instance containing the decision matrix.\nverbose: If true, prints the model information.\n\nReturns\n\nAn array of GameResult objects containing the probabilities and value of the game.\n\nExample\n\nmat = [1 4 5; 5 6 2]\n\n# 1 4 5\n# 5 6 2\n# The row player has 2 strategies, and the column player has 3 strategies.\n# If the row player selects the first strategy and the column player selects the second strategy,\n# the row player receives 4.\n\nproblem = GameProblem(mat)\n\nresult = solve(problem)\n\nresult1 = result[1]  # The result for the row player\n\nprintln(result1.probabilities)\n# 2-element Vector{Float64}:\n#  0.42857142857142855\n#  0.5714285714285714\n\nprintln(result1.value)\n# 3.285714285714285\n\nresult2 = result[2]  # The result for the column player\n\nprintln(result2.probabilities)\n# 3-element Vector{Float64}:\n#   0.42857142857142855\n#  -0.0\n#   0.5714285714285714\n\nprintln(result2.value)\n# -3.285714285714285\n\n\n\n\n\n","category":"method"},{"location":"game/#OperationsResearchModels.Game.GameResult","page":"Zero-sum Games","title":"OperationsResearchModels.Game.GameResult","text":"GameResult\n\nDescription\n\nA structure to hold the result of a game.\n\nFields\n\nprobabilities: Probabilities of the strategies\nvalue:         Value of the game\nmodel::JuMP.Model: The JuMP model used to solve the game.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Portfolio-Optimization","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"section"},{"location":"portfolio/#PortfolioProblem","page":"Portfolio Optimization","title":"PortfolioProblem","text":"","category":"section"},{"location":"portfolio/#PortfolioResult","page":"Portfolio Optimization","title":"PortfolioResult","text":"","category":"section"},{"location":"portfolio/#solve","page":"Portfolio Optimization","title":"solve","text":"","category":"section"},{"location":"portfolio/#OperationsResearchModels.Portfolio.PortfolioProblem","page":"Portfolio Optimization","title":"OperationsResearchModels.Portfolio.PortfolioProblem","text":"PortfolioProblem\n\nDescription\n\nDefines the portfolio optimization problem.\n\nFields\n\nreturns::Matrix{<:Real}: A matrix of historical returns for the assets.\nthresholdreturn::Real: The minimum expected return required for the portfolio.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#OperationsResearchModels.Portfolio.PortfolioResult","page":"Portfolio Optimization","title":"OperationsResearchModels.Portfolio.PortfolioResult","text":"PortfolioResult\n\nDescription\n\nA structure to hold the result of the portfolio optimization problem.\n\nFields\n\nweights::Vector{Float64}: The optimal weights for the assets in the portfolio.\nexpectedreturn::Float64: The expected return of the optimal portfolio.\nmodel::JuMP.Model: The JuMP model used to solve the problem.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#OperationsResearchModels.solve-Tuple{PortfolioProblem}","page":"Portfolio Optimization","title":"OperationsResearchModels.solve","text":"solve(problem)\n\nDescription\n\nSolves a portfolio optimization problem given by an object of in type PortfolioProblem. The optimization problem is formulated as a quadratic programming problem where the objective  is to minimize the portfolio variance (risk) subject to constraints on the expected return and the weights.\n\nMathematically, the problem can be stated as:\n\nMinimize: w' * Σ * w Subject to:\n\nsum(w) == 1 (the weights must sum to 1)\nsum(w[i] * μ[i] for i in 1:m) >= thresholdreturn\n0 <= w[i] <= 1 for all i (weights must be between 0 and 1)\n\nWhere:\n\nw is the vector of asset weights\nΣ is the covariance matrix of asset returns\nμ is the vector of expected returns for each asset\nthresholdreturn is the minimum expected return required for the portfolio\n\nArguments\n\nproblem::PortfolioProblem: The problem in type of PortfolioProblem\n\nReturns\n\nPortfolioResult: The result of the portfolio optimization problem, containing the optimal weights, expected return, and the JuMP model used to solve the problem.\n\n\n\n\n\n","category":"method"},{"location":"project/#Project-Analysis","page":"Project Analysis","title":"Project Analysis","text":"","category":"section"},{"location":"project/#CPM-Activity","page":"Project Analysis","title":"CPM Activity","text":"","category":"section"},{"location":"project/#CpmProblem","page":"Project Analysis","title":"CpmProblem","text":"","category":"section"},{"location":"project/#CPM-(Critical-Path-Method)","page":"Project Analysis","title":"CPM (Critical Path Method)","text":"","category":"section"},{"location":"project/#CpmResult","page":"Project Analysis","title":"CpmResult","text":"","category":"section"},{"location":"project/#PERT-Activity","page":"Project Analysis","title":"PERT Activity","text":"","category":"section"},{"location":"project/#PERT-Problem","page":"Project Analysis","title":"PERT Problem","text":"","category":"section"},{"location":"project/#PERT-(Project-Evaluation-and-Review-Technique)","page":"Project Analysis","title":"PERT (Project Evaluation and Review Technique)","text":"","category":"section"},{"location":"project/#PERT-Result","page":"Project Analysis","title":"PERT Result","text":"","category":"section"},{"location":"project/#OperationsResearchModels.CPM.CpmActivity","page":"Project Analysis","title":"OperationsResearchModels.CPM.CpmActivity","text":"CpmActivity(name::String, time::Float64, dependencies)\n\nDescription\n\nThe object that represents an activity in CPM (Critical Path Method).\n\nFields\n\nname::String: The name of the activity.\ntime::Float64: The time of the activity.\ndependencies: The dependencies of the activity in type of Vector{CpmActivity}.\n\nExample\n\nA = CpmActivity(\"A\", 2, []);\n\nB = CpmActivity(\"B\", 3, []);\n\nC = CpmActivity(\"C\", 2, [A, B]);\n\n\n\n\n\n\n","category":"type"},{"location":"project/#OperationsResearchModels.CPM.CpmProblem","page":"Project Analysis","title":"OperationsResearchModels.CPM.CpmProblem","text":"CpmProblem(activities::Vector{CpmActivity})\n\nDescription\n\nRepresents a CPM (Critical Path Method) problem instance, containing the activities.\n\nFields\n\nactivities::Vector{CpmActivity}: A vector of activities in the CPM problem.\n\n\n\n\n\n","category":"type"},{"location":"project/#OperationsResearchModels.solve-Tuple{CpmProblem}","page":"Project Analysis","title":"OperationsResearchModels.solve","text":"solve(problem)\n\nArguments\n\nproblem::CpmProblem: The problem in type of CpmProblem.\n\nOutput\n\n::CpmResult: The object holds the results \n\nDescription\n\nCalculates CPM (Critical Path Method) and reports the critical path for a given set of activities. \n\nExample\n\nA = CpmActivity(\"A\", 2);\nB = CpmActivity(\"B\", 3);\nC = CpmActivity(\"C\", 2, [A]);\nD = CpmActivity(\"D\", 3, [B]);\nE = CpmActivity(\"E\", 2, [B]);\nF = CpmActivity(\"F\", 3, [C, D]);\nG = CpmActivity(\"G\", 7, [E]);\nH = CpmActivity(\"H\", 5, [E]);\nI = CpmActivity(\"I\", 6, [G, F]);\nJ = CpmActivity(\"J\", 2, [C, D]);\n\nactivities = [A, B, C, D, E, F, G, H, I, J];\n\nproblem = CpmProblem(activities);\n\nresult = solve(problem);\n\n\n\n\n\n\n","category":"method"},{"location":"project/#OperationsResearchModels.CPM.CpmResult","page":"Project Analysis","title":"OperationsResearchModels.CPM.CpmResult","text":"CpmResult(pathstr::Vector{String}, path::Vector{CpmActivity})\n\nDescription\n\nRepresents the result of a CPM (Critical Path Method) analysis, containing the critical path and its activities.\n\nFields\n\npathstr::Vector{String}: A vector of strings representing the names of the activities in the critical path.\npath::Vector{CpmActivity}: A vector of activities representing the critical path.\n\n\n\n\n\n","category":"type"},{"location":"project/#OperationsResearchModels.CPM.PertActivity","page":"Project Analysis","title":"OperationsResearchModels.CPM.PertActivity","text":"PertActivity(name::String, o::Float64, m::Float64, p::Float64)::PertActivity\n\nDescription\n\nThe object that represents an activity in PERT (Program Evaluation and Review Technique).\n\nFields\n\nname::String: The name of the activity.\no::Float64: The optimistic time of the activity.\nm::Float64: The most likely time of the activity.\np::Float64: The pessimistic time of the activity.\ndependencies: The dependencies of the activity in type of Vector{PertActivity}.\n\nExample\n\nA = PertActivity(\"A\", 1, 2, 3);\nB = PertActivity(\"B\", 3, 3, 4);\nC = PertActivity(\"C\", 5, 6, 7, [A, B]);\n\n\n\n\n\n","category":"type"},{"location":"project/#OperationsResearchModels.CPM.PertProblem","page":"Project Analysis","title":"OperationsResearchModels.CPM.PertProblem","text":"PertProblem(activities::Vector{PertActivity})\n\nDescription\n\nRepresents a PERT (Program Evaluation and Review Technique) problem instance, containing the activities.\n\nFields\n\nactivities::Vector{PertActivity}: A vector of activities in the PERT problem.\n\n\n\n\n\n","category":"type"},{"location":"project/#OperationsResearchModels.solve-Tuple{PertProblem}","page":"Project Analysis","title":"OperationsResearchModels.solve","text":"solve(problem::PertProblem)::PertResult\n\nArguments\n\nproblem::PertProblem: The problem in type of PertProblem.\n\nOutput\n\n::PertResult: The object holds the results\n\nExample\n\nA = PertActivity(\"A\", 1, 2, 3)\n\nB = PertActivity(\"B\", 3, 3, 3)\n\nC = PertActivity(\"C\", 5, 5, 5, [A, B])\n\nactivities = [A, B, C]\n\nproblem = PertProblem(activities);\n\nresult = pert(activities)\n\nprintln(result.mean)\nprintln(result.stddev)\n\n\n\n\n\n","category":"method"},{"location":"project/#OperationsResearchModels.CPM.PertResult","page":"Project Analysis","title":"OperationsResearchModels.CPM.PertResult","text":"PertResult(path::Vector{PertActivity}, mean::Float64, stddev::Float64)\n\nDescription\n\nRepresents the result of a PERT (Program Evaluation and Review Technique) analysis, containing the critical path and its activities.\n\nFields\n\npath::Vector{PertActivity}: A vector of activities representing the critical path.\nmean::Float64: The mean duration of the critical path.\nstddev::Float64: The standard deviation of the critical path.\n\n\n\n\n\n","category":"type"},{"location":"travelingsalesman/#Traveling-Salesman","page":"Traveling Salesman","title":"Traveling Salesman","text":"","category":"section"},{"location":"travelingsalesman/#TravelingSalesmanProblem","page":"Traveling Salesman","title":"TravelingSalesmanProblem","text":"","category":"section"},{"location":"travelingsalesman/#solve","page":"Traveling Salesman","title":"solve","text":"","category":"section"},{"location":"travelingsalesman/#TravelingSalesmanResult","page":"Traveling Salesman","title":"TravelingSalesmanResult","text":"","category":"section"},{"location":"travelingsalesman/#OperationsResearchModels.TravelingSalesman.TravelingSalesmanProblem","page":"Traveling Salesman","title":"OperationsResearchModels.TravelingSalesman.TravelingSalesmanProblem","text":"TravelingSalesmanProblem\n\nDescription\n\nA data structure to hold the problem definition of the traveling salesman problem.\n\nFields\n\ndistancematrix::Matrix{Real}: The distance matrix representing the distances between cities.\n\n\n\n\n\n","category":"type"},{"location":"travelingsalesman/#OperationsResearchModels.solve-Tuple{TravelingSalesmanProblem}","page":"Traveling Salesman","title":"OperationsResearchModels.solve","text":"solve(problem::TravelingSalesmanProblem; popsize = 100, ngen = 1000, pcross = 0.8, pmutate = 0.01, nelites = 1)::TravelingSalesmanResult\n\nDescription\n\nGiven a matrix of distances wrapped in a TravelingSalesmanProblem, returns a TravelingSalesmanResult with the best route and its cost.\n\nArguments\n\nproblem::TravelingSalesmanProblem: a TravelingSalesmanProblem instance containing the distance matrix\npopsize::Int: the population size. Default is 100\nngen::Int: the number of generations. Default is 1000\npcross::Float64: the crossover probability. Default is 0.8\npmutate::Float64: the mutation probability. Default is 0.01\nnelites::Int: the number of elites. Default is 1\n\nReturns\n\nTravelingSalesmanResult: a custom data type that holds the best route and its cost\n\nExample\n\npts = Float64[\n    0 0;\n    0 1;\n    0 2;\n    1 2;\n    2 2;\n    3 2;\n    4 2; \n    5 2;\n    5 1;\n    5 0;\n    4 0;\n    3 0;\n    2 0;\n    1 0;\n]\n\nn = size(pts, 1)\ndistmat = zeros(n, n)\n\nfor i in 1:n\n    for j in 1:n\n        distmat[i, j] = sqrt(sum((pts[i, :] .- pts[j, :]).^2))\n    end \nend\n\nresult = solve(TravelingSalesmanProblem(distmat), ngen = 1000, popsize = 100, pcross = 1.0, pmutate = 0.10)\n\n\n\n\n\n","category":"method"},{"location":"travelingsalesman/#OperationsResearchModels.TravelingSalesman.TravelingSalesmanResult","page":"Traveling Salesman","title":"OperationsResearchModels.TravelingSalesman.TravelingSalesmanResult","text":"TravelingSalesmanResult\n\nDescription\n\nA data structure to hold the result of the traveling salesman problem.\n\nFields\n\nroute::Vector{Int}: The best route found.\ncost::Float64: The cost of the best route.\n\n\n\n\n\n","category":"type"},{"location":"transportation/#Transportation-Problem","page":"Transportation","title":"Transportation Problem","text":"","category":"section"},{"location":"transportation/#The-Solver","page":"Transportation","title":"The Solver","text":"","category":"section"},{"location":"transportation/#Initial-basic-solutions-for-a-transportation-problem","page":"Transportation","title":"Initial basic solutions for a transportation problem","text":"","category":"section"},{"location":"transportation/#North-west-Corner-Method","page":"Transportation","title":"North-west Corner Method","text":"","category":"section"},{"location":"transportation/#The-Least-Cost-Method","page":"Transportation","title":"The Least Cost Method","text":"","category":"section"},{"location":"transportation/#OperationsResearchModels.Transportation.TransportationProblem","page":"Transportation","title":"OperationsResearchModels.Transportation.TransportationProblem","text":"TransportationProblem\n\nFields\n\ncosts::Matrix{T}: The cost matrix of the transportation problem.\ndemand::Vector{T}: The demand vector of the transportation problem.\nsupply::Vector{T}: The supply vector of the transportation problem.\n\nDescription\n\nThe TransportationProblem struct represents a transportation problem with a cost matrix, demand vector, and supply vector.\n\n\n\n\n\n","category":"type"},{"location":"transportation/#OperationsResearchModels.solve-Tuple{TransportationProblem}","page":"Transportation","title":"OperationsResearchModels.solve","text":"solve(t, initial = NoInitial)\n\nArguments\n\nt::TransportationProblem: The problem in type of TransportationProblem\ninitial::TransportationResult: The initial solution of the transportation problem (optional). The default is NoInitial.\n\nOutput\n\nTransportationResult: The custom data type that holds problem, solution, and optimum cost. \n\nDescription\n\nSolves a transportation problem given by an object of in type TransportationProblem.\n\ninitial is used to store the initial solution of the transportation problem. Any custom  implementation should take a TransportationProblem and return a TransportationResult object. Currently, northwestcorner and leastcost are implemented as custom initial solutions.\n\nExample\n\nt = TransportationProblem(\n    [   1 1 1 1; \n        2 2 2 2; \n        3 3 3 3], \n    [100, 100, 100, 100], # Demands \n    [100, 100, 100])      # Supplies \n\n\nprintln(isbalanced(t))\n# false\n\nresult = solve(t)\n\nprintln(result)\n\n# Transportation Results:\n# Main problem:\n# Transportation Problem:\n# Costs: [1 1 1 1; 2 2 2 2; 3 3 3 3]\n# Demand: [100, 100, 100, 100]\n# Supply: [100, 100, 100]\n# \n# Balanced problem:\n# Transportation Problem:\n# Costs: [1 1 1 1; 2 2 2 2; 3 3 3 3; 0 0 0 0]\n# Demand: [100, 100, 100, 100]\n# Supply: [100, 100, 100, 100]\n# \n# Cost:\n# 600.0\n# Solution:\n# [-0.0 -0.0 -0.0 100.0; 100.0 -0.0 -0.0 -0.0; -0.0 -0.0 100.0 -0.0; -0.0 100.0 -0.0 -0.0]\n\n\n\n\n\n","category":"method"},{"location":"transportation/#OperationsResearchModels.Transportation.TransportationResult","page":"Transportation","title":"OperationsResearchModels.Transportation.TransportationResult","text":"TransportationResult(problem, balancedProblem, solution, cost)\n\nFields\n\nproblem::TransportationProblem: The original transportation problem.\nbalancedProblem::TransportationProblem: The balanced transportation problem.\nsolution::Matrix: The solution matrix of the transportation problem.\ncost::Real: The optimal cost of the transportation problem.\nmodel::Union{JuMP.Model, Nothing}: The JuMP model used to solve the transportation problem. Methods that    do not use JuMP will set this field to nothing.\n\nDescription\n\nThe TransportationResult struct represents the result of solving a transportation problem. It contains the original problem, the balanced problem, the solution matrix, and the optimal cost.\n\n\n\n\n\n","category":"type"},{"location":"transportation/#OperationsResearchModels.Transportation.northwestcorner","page":"Transportation","title":"OperationsResearchModels.Transportation.northwestcorner","text":"northwestcorner(a::TransportationProblem)::TransportationResult\n\nDescription\n\nThe northwest corner method is a heuristic for finding an initial basic feasible solution to a transportation problem. It starts at the northwest corner of the cost matrix and allocates as much as possible to the cell, then moves either down or right depending on whether the supply or demand has been met. The method continues until all supply and demand constraints are satisfied.\n\nArguments\n\na::TransportationProblem: The problem in type of TransportationProblem\n\nOutput\n\nTransportationResult: The custom data type that holds problem, solution, and optimum cost.\n\n\n\n\n\n","category":"function"},{"location":"transportation/#OperationsResearchModels.Transportation.leastcost","page":"Transportation","title":"OperationsResearchModels.Transportation.leastcost","text":"leastcost(a::TransportationProblem)::TransportationResult\n\nDescription\n\nThe least cost method is a heuristic for finding an initial basic feasible solution to a transportation problem. It starts by selecting the cell with the lowest cost and allocating as much as possible to that cell, then it moves to the next lowest cost cell and repeats the process until all supply and demand constraints are satisfied.\n\nArguments\n\na::TransportationProblem: The problem in type of TransportationProblem\n\nOutput\n\nTransportationResult: The custom data type that holds problem, solution, and optimum cost.\n\n\n\n\n\n","category":"function"},{"location":"locationselection/#pmedian","page":"Location Selection","title":"pmedian","text":"","category":"section"},{"location":"locationselection/#pmedian-with-distances","page":"Location Selection","title":"pmedian with distances","text":"","category":"section"},{"location":"locationselection/#OperationsResearchModels.PMedian.pmedian","page":"Location Selection","title":"OperationsResearchModels.PMedian.pmedian","text":"pmedian(data, ncenters)\n\nDescription\n\nThe function calculates Euclidean distances between all possible rows of the matrix data.  ncenters locations are then selected that minimizes the total distances to the nearest rows.\n\nArguments\n\ndata::Matrix: Coordinates of locations \nncenters::Int: Number of centers  \n\nOutput\n\nPMedianResult: PMedianResult object. \n\nExample\n\ndata1 = rand(10, 2)\n\ndata2 = rand(10, 2) .+ 50\n\ndata3 = rand(10, 2) .+ 100\n\ndata = vcat(data1, data2, data3)\n\nresult = pmedian(data, 3);\n\nprintln(result.centers)\n# 3-element Vector{Int64}:\n#  1\n# 16\n# 21\n\nprintln(result.objective)\n# 11.531012240599605\n\n\n\n\n\n","category":"function"},{"location":"locationselection/#OperationsResearchModels.PMedian.pmedian_with_distances","page":"Location Selection","title":"OperationsResearchModels.PMedian.pmedian_with_distances","text":"pmedian_with_distances(distancematrix, ncenters)\n\nDescription\n\nncenters locations are selected that minimizes the total distances to the nearest rows. \n\nArguments\n\ndistancematrix::Matrix: n x n matrix of distances\nncenters::Int: Number of centers \n\nOutput\n\nPMedianResult: PMedianResult object. \n\n\n\n\n\n","category":"function"},{"location":"","page":"OperationsResearchModels.jl","title":"OperationsResearchModels.jl","text":"(Image: Doc) (Image: status)","category":"section"},{"location":"#OperationsResearchModels.jl","page":"OperationsResearchModels.jl","title":"OperationsResearchModels.jl","text":"A package for Operations Research problems.","category":"section"},{"location":"#Installation","page":"OperationsResearchModels.jl","title":"Installation","text":"julia> ]\n(@v1.xx) pkg> add OperationsResearchModels\n\nor \n\njulia> using Pkg\njulia> Pkg.add(\"OperationsResearchModels\")\n\nIf you want to install latest source that is not registered yet, you can \n\njulia> ]\n(@1.xx) pkg> add https://github.com/jbytecode/OperationsResearchModels.jl\n\nbut it's not recommended.","category":"section"},{"location":"#Documentation","page":"OperationsResearchModels.jl","title":"Documentation","text":"Please visit The Documentation Page.  This page includes both the API documentation and examples.","category":"section"},{"location":"#Implemented-Problems-and-Algorithms","page":"OperationsResearchModels.jl","title":"Implemented Problems and Algorithms","text":"Assignment Problem\nTransportation Problem\nThe Shortest Path\nMaximum Flow\nMinimum Cost-Flow\nMinimum Spanning Tree\np-median for Location Selection\nCPM - Critical Path Method\nPERT - Project Evaluation and Review Technique\nThe Knapsack Problem\nJohnson's Rule for Flow-Shop Scheduling\nFlow-shop Scheduling using Permutation Encoded Genetic Algorithms (using a Random Key Genetic Algorithm)\nTraveling Salesman with Random Key Genetic Algorithm\nSimplex Method with Real Valued Decision Variables\n2-player zero-sum game solver","category":"section"},{"location":"#How-to-contribute","page":"OperationsResearchModels.jl","title":"How to contribute","text":"Please read the page Contributing before contributing.","category":"section"},{"location":"#Notes-for-the-users","page":"OperationsResearchModels.jl","title":"Notes for the users","text":"The package is implemented for mostly academic purposes. The implementations are not optimized for large-scale problems. The users are encouraged to use the package for educational purposes and small-scale problems. ","category":"section"}]
}
